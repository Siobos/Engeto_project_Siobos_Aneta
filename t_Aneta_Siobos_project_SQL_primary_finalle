CZECHIA_PAYROLL

SELECT 
	industry_branch_code, payroll_year, 
	AVG(value) AS avg_value
FROM czechia_payroll cp 
WHERE value_type_code = '5958' AND industry_branch_code IS NOT NULL
GROUP BY industry_branch_code, payroll_year;


SELECT 
	industry_branch_code, payroll_year, cpib.name,
	ROUND(AVG(value),2) AS avg_value
FROM czechia_payroll cp 
	LEFT JOIN czechia_payroll_industry_branch cpib 
	ON cp.industry_branch_code = cpib.code	
WHERE value_type_code = '5958' AND industry_branch_code IS NOT NULL
GROUP BY industry_branch_code, payroll_year;

SELECT 
	industry_branch_code, payroll_year, cpib.name, cpu.name,
	ROUND(AVG(value),2) AS avg_value
FROM czechia_payroll cp 
	LEFT JOIN czechia_payroll_industry_branch cpib 
	ON cp.industry_branch_code = cpib.code	
	LEFT JOIN czechia_payroll_unit cpu
	ON cp.unit_code = cpu.code	
WHERE value_type_code = '5958' AND industry_branch_code IS NOT NULL
GROUP BY industry_branch_code, payroll_year;

CREATE TABLE czechia_payroll_selection
SELECT 
	industry_branch_code, payroll_year, cpib.name, cpu.name AS unit,
	ROUND(AVG(value),2) AS avg_value
FROM czechia_payroll cp 
	LEFT JOIN czechia_payroll_industry_branch cpib 
	ON cp.industry_branch_code = cpib.code	
	LEFT JOIN czechia_payroll_unit cpu
	ON cp.unit_code = cpu.code	
WHERE value_type_code = '5958' AND industry_branch_code IS NOT NULL
GROUP BY industry_branch_code, payroll_year;

CZECHIA_PRICE
Průměrné hodnoty ale neodpovídají:
SELECT 
ROUND(AVG(value),2) AS avg_value,
YEAR(date_from) AS year,
category_code,
cpc.name, cpc.price_value, cpc.price_unit
FROM czechia_price cp
LEFT JOIN czechia_price_category cpc 
	ON cp.category_code = cpc.code
GROUP BY year(date_from), category_code;


CREATE TABLE czechia_price_selection
SELECT 
ROUND(AVG(value),2) AS avg_value,
YEAR(date_from) AS year,
category_code,
cpc.name,
concat (cpc.price_value, cpc.price_unit) AS price_value_unit
FROM czechia_price cp
LEFT JOIN czechia_price_category cpc 
	ON cp.category_code = cpc.code
GROUP BY year(date_from), category_code;

SLOUČENÍ TABULEK CZECHIA_PRICE_SELECTION A CZECHIA_PAYROLL_SELECTION
SELECT year, category_code, name, avg_value, unit COLLATE utf8_general_ci AS unit
FROM czechia_payroll_selection cps 
UNION ALL
SELECT year, category_code, name, avg_value, unit COLLATE utf8_general_ci
FROM czechia_price_selection cps2

VYTVOŘENÍ FINAL TABULKY 1
CREATE TABLE t_Aneta_Siobos_project_SQL_primary_final
SELECT year, category_code, name, avg_value, unit COLLATE utf8_general_ci AS unit
FROM czechia_payroll_selection cps 
UNION ALL
SELECT year, category_code, name, avg_value, unit COLLATE utf8_general_ci
FROM czechia_price_selection cps2

1) Rostou v průběhu let mzdy ve všech odvětvích, nebo v některých klesají?
Nefunguje
SELECT *,
CASE 
	WHEN avg_value IN (YEAR = 2000) THEN '-'
	WHEN avg_value IN (YEAR = 2000) < avg_value IN (YEAR = 2001) THEN 'increase'
	WHEN avg_value IN (YEAR = 2001) < avg_value IN (YEAR = 2002) THEN 'increase'	
	ELSE 'decrease'
END AS increase_decrease_wages
FROM czechia_payroll_selection cps 
ORDER BY category_code, year;


Ostatní varianty:
Funguje:
SELECT *,
CASE 
	WHEN avg_value > '11500' THEN 'increase'
	ELSE 'decrease'
END AS increase_decrease_wages
FROM czechia_payroll_selection cps 
ORDER BY category_code, year;


SELECT cps1.*, cps2.*,
    CASE 
        WHEN cps1.avg_value > cps2.avg_value THEN 'increase'
        ELSE 'decrease'
    END AS increase_decrease_wages
FROM (
    SELECT * 
    FROM czechia_payroll_selection 
    WHERE category_code = 'A' AND year = 2000
) AS cps1
JOIN (
    SELECT * 
    FROM czechia_payroll_selection 
    WHERE category_code = 'A' AND year = 2001
) AS cps2;





2) Kolik je možné si koupit litrů mléka a kilogramů chleba za první a poslední srovnatelné období v dostupných datech cen a mezd?
část vnořeného selectu:
SELECT YEAR, avg(avg_value)
FROM czechia_payroll_selection cps 
WHERE YEAR IN (2006, 2018)
GROUP BY year

nebo>
SELECT YEAR, avg(avg_value)
FROM t_aneta_siobos_project_sql_primary_final taspspf  
WHERE YEAR IN (2006, 2018) AND category_code IN ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S')
GROUP BY YEAR

a to spojit s tímhle:
SELECT YEAR, avg(avg_value)
FROM t_aneta_siobos_project_sql_primary_final taspspf  
WHERE YEAR IN (2006, 2018) AND category_code IN ('111301','114201')
GROUP BY YEAR	

Výsledek:
SELECT YEAR, ROUND(avg(avg_value),2) AS avg_value, unit
FROM t_aneta_siobos_project_sql_primary_final taspspf  
WHERE YEAR IN (2006, 2018) AND category_code IN ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S')
GROUP BY YEAR
UNION
SELECT YEAR, avg_value, unit
FROM t_aneta_siobos_project_sql_primary_final taspspf  
WHERE YEAR IN (2006, 2018) AND category_code IN ('111301','114201')
GROUP BY YEAR, category_code 

3) Která kategorie potravin zdražuje nejpomaleji (je u ní nejnižší percentuální meziroční nárůst)?

První pokus, co hodí na konci sloupec s posunutím hodnot o 1 ted tam dát nějak ty výpočty:
SELECT *,
LEAD(avg_value, 1) OVER (
PARTITION BY category_code
ORDER BY year
	) results
FROM t_aneta_siobos_project_sql_primary_final taspspf 

WITH t_aneta_siobos_project_sql_primary_final_calculations AS (
SELECT *,
LEAD(avg_value, 1) OVER (
PARTITION BY category_code
ORDER BY year
	) results
FROM t_aneta_siobos_project_sql_primary_final taspspf
)
SELECT *,
	CASE
        WHEN results > avg_value THEN 'increase'
        WHEN results < avg_value THEN 'decrease'
        WHEN results = avg_value THEN 'stagnation'
        ELSE '-'
    END AS grow
FROM t_aneta_siobos_project_sql_primary_final_calculations;
